<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsigc++: Signals</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libsigc++<span id="projectnumber">&#160;3.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle"><div class="title">Signals</div></div>
</div><!--header-->
<div class="contents">

<p>Use <a class="el" href="classsigc_1_1signal__with__accumulator.html#a3765ae85a8ffaae0d48afa15fffe6009">sigc::signal::connect()</a> or <a class="el" href="classsigc_1_1signal__with__accumulator.html#a6887c2139445ff606c2cd0822ac81917">sigc::signal::connect_first()</a> with <a class="el" href="group__mem__fun.html#ga5d28dcf1bb88830a6e50d08d1fe7ec08" title="Creates a functor of type sigc::mem_functor which wraps a method.">sigc::mem_fun()</a> and <a class="el" href="group__ptr__fun.html#ga90d9748e4be611e80869c0a6a8d8e62a" title="Creates a functor of type sigc::pointer_functor which wraps an existing non-member function.">sigc::ptr_fun()</a> to connect a method or function with a signal.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1connection.html">sigc::connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience class for safe disconnection.  <a href="structsigc_1_1connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1scoped__connection.html">sigc::scoped_connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience class for safe disconnection, including automatic disconnection upon destruction.  <a href="structsigc_1_1scoped__connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_07T__arg_8_8_8_08_4.html">sigc::signal&lt; T_return(T_arg...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">signal can be used to <a class="el" href="classsigc_1_1signal__with__accumulator.html#a3765ae85a8ffaae0d48afa15fffe6009" title="Add a slot at the end of the list of slots.">connect()</a> slots that are invoked during subsequent calls to <a class="el" href="classsigc_1_1signal__with__accumulator.html#a9cdd5ffe58f2445a1012c7be05f7029f" title="Triggers the emission of the signal.">emit()</a>.  <a href="classsigc_1_1signal_3_01T__return_07T__arg_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_07T__arg_8_8_8_08_4_1_1accumulated.html">sigc::signal&lt; T_return(T_arg...)&gt;::accumulated&lt; T_accumulator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classsigc_1_1signal_3_01T__return_07T__arg_8_8_8_08_4.html">sigc::signal</a> but the additional template parameter <em>T_accumulator</em> defines the accumulator type that should be used.  <a href="classsigc_1_1signal_3_01T__return_07T__arg_8_8_8_08_4_1_1accumulated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1signal__base.html">sigc::signal_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the <a class="el" href="classsigc_1_1signal_3_01T__return_07T__arg_8_8_8_08_4.html">sigc::signal</a> template.  <a href="structsigc_1_1signal__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal__with__accumulator.html">sigc::signal_with_accumulator&lt; T_return, T_accumulator, T_arg &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal__with__accumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for objects with auto-disconnection.  <a href="structsigc_1_1trackable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1trackable__signal_3_01T__return_07T__arg_8_8_8_08_4.html">sigc::trackable_signal&lt; T_return(T_arg...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">trackable_signal can be used to <a class="el" href="classsigc_1_1trackable__signal__with__accumulator.html#a0f10465f8ff1b2af410937ca80971522" title="Add a slot at the end of the list of slots.">connect()</a> slots that are invoked during subsequent calls to <a class="el" href="classsigc_1_1trackable__signal__with__accumulator.html#a547fff9c2844aa9826fb3441da6be7b3" title="Triggers the emission of the signal.">emit()</a>.  <a href="classsigc_1_1trackable__signal_3_01T__return_07T__arg_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1trackable__signal_3_01T__return_07T__arg_8_8_8_08_4_1_1accumulated.html">sigc::trackable_signal&lt; T_return(T_arg...)&gt;::accumulated&lt; T_accumulator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classsigc_1_1trackable__signal_3_01T__return_07T__arg_8_8_8_08_4.html">sigc::trackable_signal</a> but the additional template parameter <em>T_accumulator</em> defines the accumulator type that should be used.  <a href="classsigc_1_1trackable__signal_3_01T__return_07T__arg_8_8_8_08_4_1_1accumulated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1trackable__signal__with__accumulator.html">sigc::trackable_signal_with_accumulator&lt; T_return, T_accumulator, T_arg &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1trackable__signal__with__accumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Use <a class="el" href="classsigc_1_1signal__with__accumulator.html#a3765ae85a8ffaae0d48afa15fffe6009">sigc::signal::connect()</a> or <a class="el" href="classsigc_1_1signal__with__accumulator.html#a6887c2139445ff606c2cd0822ac81917">sigc::signal::connect_first()</a> with <a class="el" href="group__mem__fun.html#ga5d28dcf1bb88830a6e50d08d1fe7ec08" title="Creates a functor of type sigc::mem_functor which wraps a method.">sigc::mem_fun()</a> and <a class="el" href="group__ptr__fun.html#ga90d9748e4be611e80869c0a6a8d8e62a" title="Creates a functor of type sigc::pointer_functor which wraps an existing non-member function.">sigc::ptr_fun()</a> to connect a method or function with a signal. </p>
<div class="fragment"><div class="line">signal_clicked.connect( <a class="code hl_function" href="group__mem__fun.html#ga5d28dcf1bb88830a6e50d08d1fe7ec08">sigc::mem_fun</a>(*<span class="keyword">this</span>, &amp;MyWindow::on_clicked) );</div>
<div class="ttc" id="agroup__mem__fun_html_ga5d28dcf1bb88830a6e50d08d1fe7ec08"><div class="ttname"><a href="group__mem__fun.html#ga5d28dcf1bb88830a6e50d08d1fe7ec08">sigc::mem_fun</a></div><div class="ttdeci">decltype(auto) mem_fun(T_return(T_obj::*func)(T_arg...))</div><div class="ttdoc">Creates a functor of type sigc::mem_functor which wraps a method.</div><div class="ttdef"><b>Definition:</b> mem_fun.h:188</div></div>
</div><!-- fragment --><p >When the signal is emitted your method will be called.</p>
<p >signal::connect() returns a connection, which you can later use to disconnect your method. If the type of your object inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> the method is disconnected automatically when your object is destroyed.</p>
<p >When signals are copied they share the underlying information, so you can have a protected/private <a class="el" href="classsigc_1_1signal_3_01T__return_07T__arg_8_8_8_08_4.html">sigc::signal</a> member and a public accessor method. A sigc::signal is a kind of reference-counting pointer. It's similar to std::shared_ptr&lt;&gt;, although sigc::signal is restricted to holding a pointer to a sigc::internal::signal_impl object that contains the implementation of the signal.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span>MySignalType = sigc::signal&lt;void()&gt;;</div>
<div class="line">  MySignalType get_my_signal() { <span class="keywordflow">return</span> m_my_signal; }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  MySignalType m_my_signal;</div>
<div class="line">};</div>
</div><!-- fragment --><p >signal and slot objects provide the core functionality of this library. A slot is a container for an arbitrary functor. A signal is a list of slots that are executed on emission. For compile time type safety a list of template arguments must be provided for the signal template that determines the parameter list for emission. Functors and closures are converted into slots implicitly on connection, triggering compiler errors if the given functor or closure cannot be invoked with the parameter list of the signal to connect to.</p>
<p >Almost any functor with the correct signature can be converted to a <a class="el" href="classsigc_1_1slot_3_01T__return_07T__arg_8_8_8_08_4.html">sigc::slot</a> and connected to a signal. See <a class="el" href="group__slot.html">Slots</a> and <a class="el" href="classsigc_1_1signal__with__accumulator.html#a3765ae85a8ffaae0d48afa15fffe6009">sigc::signal::connect()</a>. </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 1 2023 10:25:44 for libsigc++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
